# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/library/struct.rst:3
msgid ":mod:`struct` --- Interpret strings as packed binary data"
msgstr ""

#: ../Doc/library/struct.rst:12
msgid ""
"This module performs conversions between Python values and C structs "
"represented as Python strings.  This can be used in handling binary data "
"stored in files or from network connections, among other sources.  It uses :"
"ref:`struct-format-strings` as compact descriptions of the layout of the C "
"structs and the intended conversion to/from Python values."
msgstr ""

#: ../Doc/library/struct.rst:20
msgid ""
"By default, the result of packing a given C struct includes pad bytes in "
"order to maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  This behavior is chosen so "
"that the bytes of a packed struct correspond exactly to the layout in memory "
"of the corresponding C struct.  To handle platform-independent data formats "
"or omit implicit pad bytes, use ``standard`` size and alignment instead of "
"``native`` size and alignment: see :ref:`struct-alignment` for details."
msgstr ""
"par défaut, le résultat de l'agrégation d'une structure C donnée comprend "
"des octets de bourrage afin de maintenir un alignement correct des types C "
"sous-jacents ; de la même manière, l'alignement est pris en compte lors de "
"la dissociation. Ce comportement a été choisi de manière à ce que les octets "
"d'une structure agrégée reproduisent exactement l'agencement en mémoire de "
"la structure C équivalente. Pour gérer des formats de données indépendants "
"de la plateforme ou omettre les octets implicites de bourrage, utilisez la "
"taille et l'alignement ``standard`` en lieu et place de la taille et "
"l'alignement ``native`` (voir :ref:`struct-alignment` pour les détails)."

#: ../Doc/library/struct.rst:29
msgid "Functions and Exceptions"
msgstr "Fonctions et exceptions"

#: ../Doc/library/struct.rst:31
msgid "The module defines the following exception and functions:"
msgstr "Le module définit les exceptions et fonctions suivantes :"

#: ../Doc/library/struct.rst:36
msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""
"Exception levée à plusieurs occasions ; l'argument est une chaîne qui décrit "
"ce qui ne va pas."

#: ../Doc/library/struct.rst:42
msgid ""
"Return a string containing the values ``v1, v2, ...`` packed according to "
"the given format.  The arguments must match the values required by the "
"format exactly."
msgstr ""

#: ../Doc/library/struct.rst:49
msgid ""
"Pack the values ``v1, v2, ...`` according to the given format, write the "
"packed bytes into the writable *buffer* starting at *offset*. Note that the "
"offset is a required argument."
msgstr ""

#: ../Doc/library/struct.rst:58
msgid ""
"Unpack the string (presumably packed by ``pack(fmt, ...)``) according to the "
"given format.  The result is a tuple even if it contains exactly one item. "
"The string must contain exactly the amount of data required by the format "
"(``len(string)`` must equal ``calcsize(fmt)``)."
msgstr ""

#: ../Doc/library/struct.rst:66
msgid ""
"Unpack the *buffer* according to the given format. The result is a tuple "
"even if it contains exactly one item. The *buffer* must contain at least the "
"amount of data required by the format (``len(buffer[offset:])`` must be at "
"least ``calcsize(fmt)``)."
msgstr ""

#: ../Doc/library/struct.rst:76
msgid ""
"Return the size of the struct (and hence of the string) corresponding to the "
"given format."
msgstr ""

#: ../Doc/library/struct.rst:82
msgid "Format Strings"
msgstr "Chaînes de spécification du format"

#: ../Doc/library/struct.rst:84
msgid ""
"Format strings are the mechanism used to specify the expected layout when "
"packing and unpacking data.  They are built up from :ref:`format-"
"characters`, which specify the type of data being packed/unpacked.  In "
"addition, there are special characters for controlling the :ref:`struct-"
"alignment`."
msgstr ""
"Les chaînes de spécification du format servent à définir l'agencement lors "
"de l'agrégation et la dissociation des données. Elles sont construites à "
"partir de :ref:`caractères de format <format-characters>`, qui spécifient le "
"type de donnée à agréger-dissocier. De plus, il existe des caractères "
"spéciaux pour contrôler :ref:`le boutisme, la taille et l'alignement <struct-"
"alignment>`."

#: ../Doc/library/struct.rst:93
msgid "Byte Order, Size, and Alignment"
msgstr "Boutisme, taille et alignement"

#: ../Doc/library/struct.rst:95
msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler)."
msgstr ""
"Par défaut, les types C sont représentés dans le format et le boutisme "
"natifs de la machine ; ils sont alignés correctement en sautant des octets "
"si nécessaire (en fonction des règles utilisées par le compilateur C)."

#: ../Doc/library/struct.rst:99
msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""
"Cependant, le premier caractère de la chaîne de format peut être utilisé "
"pour indiquer le boutisme, la taille et l'alignement des données agrégées, "
"conformément à la table suivante :"

#: ../Doc/library/struct.rst:104
msgid "Character"
msgstr "Caractère"

#: ../Doc/library/struct.rst:104
msgid "Byte order"
msgstr "Boutisme"

#: ../Doc/library/struct.rst:104
msgid "Size"
msgstr "Taille"

#: ../Doc/library/struct.rst:104
msgid "Alignment"
msgstr "Alignement"

#: ../Doc/library/struct.rst:106
msgid "``@``"
msgstr "``@``"

#: ../Doc/library/struct.rst:106 ../Doc/library/struct.rst:108
msgid "native"
msgstr "natif"

#: ../Doc/library/struct.rst:108
msgid "``=``"
msgstr "``=``"

#: ../Doc/library/struct.rst:108 ../Doc/library/struct.rst:110
#: ../Doc/library/struct.rst:112 ../Doc/library/struct.rst:114
msgid "standard"
msgstr "standard"

#: ../Doc/library/struct.rst:108 ../Doc/library/struct.rst:110
#: ../Doc/library/struct.rst:112 ../Doc/library/struct.rst:114
msgid "none"
msgstr "aucun"

#: ../Doc/library/struct.rst:110
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/struct.rst:110
msgid "little-endian"
msgstr "petit-boutiste"

#: ../Doc/library/struct.rst:112
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/struct.rst:112
msgid "big-endian"
msgstr "gros-boutiste"

#: ../Doc/library/struct.rst:114
msgid "``!``"
msgstr "``!``"

#: ../Doc/library/struct.rst:114
msgid "network (= big-endian)"
msgstr "réseau (= gros-boutiste)"

#: ../Doc/library/struct.rst:117
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr ""
"Si le premier caractère n'est pas dans cette liste, le module se comporte "
"comme si ``'@'`` avait été indiqué."

#: ../Doc/library/struct.rst:119
msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86 and AMD64 (x86-64) are little-endian; "
"Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature "
"switchable endianness (bi-endian). Use ``sys.byteorder`` to check the "
"endianness of your system."
msgstr ""
"Le boutisme natif est gros-boutiste ou petit-boutiste, en fonction de la "
"machine sur laquelle s'exécute le programme. Par exemple, les Intel x86 et "
"les AMD64 (x86-64) sont petit-boutistes ; les Motorola 68000 et les *PowerPC "
"G5* sont gros-boutistes ; les ARM et les Intel Itanium peuvent changer de "
"boutisme. Utilisez ``sys.byteorder`` pour vérifier le boutisme de votre "
"système."

#: ../Doc/library/struct.rst:125
msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""
"La taille et l'alignement natifs sont déterminés en utilisant l'expression "
"``sizeof`` du compilateur C. Leur valeur est toujours combinée au boutisme "
"natif."

#: ../Doc/library/struct.rst:128
msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr ""
"La taille standard dépend seulement du caractère du format ; référez-vous au "
"tableau dans la section :ref:`format-characters`."

#: ../Doc/library/struct.rst:131
msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""
"Notez la différence entre ``'@'`` et ``'='`` : les deux utilisent le "
"boutisme natif mais la taille et l'alignement du dernier sont standards."

#: ../Doc/library/struct.rst:134
msgid ""
"The form ``'!'`` is available for those poor souls who claim they can't "
"remember whether network byte order is big-endian or little-endian."
msgstr ""
"La forme ``'!'`` existe pour les têtes en l'air qui prétendent ne pas se "
"rappeler si le boutisme réseau est gros-boutiste ou petit-boutiste."

#: ../Doc/library/struct.rst:137
msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""
"Il n'y a pas de moyen de spécifier le boutisme contraire au boutisme natif "
"(c'est-à-dire forcer la permutation des octets) ; utilisez le bon caractère "
"entre ``'<'`` et ``'>'``."

#: ../Doc/library/struct.rst:140 ../Doc/library/struct.rst:206
msgid "Notes:"
msgstr "Notes :"

#: ../Doc/library/struct.rst:142
msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr ""
"Le bourrage (*padding* en anglais) n'est automatiquement ajouté qu'entre les "
"membres successifs de la structure. Il n'y a pas de bourrage au début ou à "
"la fin de la structure agrégée."

#: ../Doc/library/struct.rst:145
msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr ""
"Il n'y a pas d'ajout de bourrage lorsque vous utilisez une taille et un "
"alignement non-natifs, par exemple avec `<`, `'>', `=` ou `!`."

#: ../Doc/library/struct.rst:148
msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr ""
"Pour aligner la fin d'une structure à l'alignement requis par un type "
"particulier, terminez le format avec le code du type voulu et une valeur de "
"répétition à zéro. Référez-vous à :ref:`struct-examples`."

#: ../Doc/library/struct.rst:156
msgid "Format Characters"
msgstr "Caractères de format"

#: ../Doc/library/struct.rst:158
msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"Les caractères de format possèdent les significations suivantes ; la "
"conversion entre les valeurs C et Python doit être évidente compte tenu des "
"types concernés. La colonne « taille standard » fait référence à la taille "
"en octets de la valeur agrégée avec l'utilisation de la taille standard "
"(c'est-à-dire lorsque la chaîne de format commence par l'un des caractères "
"suivants : ``'<'``, ``'>'``, ``'!'`` ou ``'='``). Si vous utilisez la taille "
"native, la taille de la valeur agrégée dépend de la plateforme."

#: ../Doc/library/struct.rst:166
msgid "Format"
msgstr "Format"

#: ../Doc/library/struct.rst:166
msgid "C Type"
msgstr "Type C"

#: ../Doc/library/struct.rst:166
msgid "Python type"
msgstr "Type Python"

#: ../Doc/library/struct.rst:166
msgid "Standard size"
msgstr "Taille standard"

#: ../Doc/library/struct.rst:166
msgid "Notes"
msgstr "Notes"

#: ../Doc/library/struct.rst:168
msgid "``x``"
msgstr "``x``"

#: ../Doc/library/struct.rst:168
msgid "pad byte"
msgstr "octet de bourrage"

#: ../Doc/library/struct.rst:168
msgid "no value"
msgstr "pas de valeur"

#: ../Doc/library/struct.rst:170
msgid "``c``"
msgstr "``c``"

#: ../Doc/library/struct.rst:170
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: ../Doc/library/struct.rst:170
msgid "string of length 1"
msgstr ""

#: ../Doc/library/struct.rst:170 ../Doc/library/struct.rst:172
#: ../Doc/library/struct.rst:174 ../Doc/library/struct.rst:176
msgid "1"
msgstr "1"

#: ../Doc/library/struct.rst:172
msgid "``b``"
msgstr "``b``"

#: ../Doc/library/struct.rst:172
msgid ":c:type:`signed char`"
msgstr ":c:type:`signed char`"

#: ../Doc/library/struct.rst:172 ../Doc/library/struct.rst:174
#: ../Doc/library/struct.rst:178 ../Doc/library/struct.rst:180
#: ../Doc/library/struct.rst:182 ../Doc/library/struct.rst:184
#: ../Doc/library/struct.rst:186 ../Doc/library/struct.rst:188
#: ../Doc/library/struct.rst:190 ../Doc/library/struct.rst:192
#: ../Doc/library/struct.rst:203
msgid "integer"
msgstr "*int* (entier)"

#: ../Doc/library/struct.rst:172 ../Doc/library/struct.rst:174
#: ../Doc/library/struct.rst:178 ../Doc/library/struct.rst:180
#: ../Doc/library/struct.rst:182 ../Doc/library/struct.rst:184
#: ../Doc/library/struct.rst:186 ../Doc/library/struct.rst:188
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/struct.rst:174
msgid "``B``"
msgstr "``B``"

#: ../Doc/library/struct.rst:174
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../Doc/library/struct.rst:176
msgid "``?``"
msgstr "``?``"

#: ../Doc/library/struct.rst:176
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../Doc/library/struct.rst:176
msgid "bool"
msgstr "bool"

#: ../Doc/library/struct.rst:176
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/struct.rst:178
msgid "``h``"
msgstr "``h``"

#: ../Doc/library/struct.rst:178
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: ../Doc/library/struct.rst:178 ../Doc/library/struct.rst:180
msgid "2"
msgstr "2"

#: ../Doc/library/struct.rst:180
msgid "``H``"
msgstr "``H``"

#: ../Doc/library/struct.rst:180
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../Doc/library/struct.rst:182
msgid "``i``"
msgstr "``i``"

#: ../Doc/library/struct.rst:182
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: ../Doc/library/struct.rst:182 ../Doc/library/struct.rst:184
#: ../Doc/library/struct.rst:186 ../Doc/library/struct.rst:188
#: ../Doc/library/struct.rst:195
msgid "4"
msgstr "4"

#: ../Doc/library/struct.rst:184
msgid "``I``"
msgstr "``I``"

#: ../Doc/library/struct.rst:184
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../Doc/library/struct.rst:186
msgid "``l``"
msgstr "``l``"

#: ../Doc/library/struct.rst:186
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: ../Doc/library/struct.rst:188
msgid "``L``"
msgstr "``L``"

#: ../Doc/library/struct.rst:188
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../Doc/library/struct.rst:190
msgid "``q``"
msgstr "``q``"

#: ../Doc/library/struct.rst:190
msgid ":c:type:`long long`"
msgstr ":c:type:`long long`"

#: ../Doc/library/struct.rst:190 ../Doc/library/struct.rst:192
#: ../Doc/library/struct.rst:197
msgid "8"
msgstr "8"

#: ../Doc/library/struct.rst:190 ../Doc/library/struct.rst:192
msgid "\\(2), \\(3)"
msgstr "\\(2), \\(3)"

#: ../Doc/library/struct.rst:192
msgid "``Q``"
msgstr "``Q``"

#: ../Doc/library/struct.rst:192
msgid ":c:type:`unsigned long long`"
msgstr ":c:type:`unsigned long long`"

#: ../Doc/library/struct.rst:195
msgid "``f``"
msgstr "``f``"

#: ../Doc/library/struct.rst:195
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: ../Doc/library/struct.rst:195 ../Doc/library/struct.rst:197
msgid "float"
msgstr "*float*"

#: ../Doc/library/struct.rst:195 ../Doc/library/struct.rst:197
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/struct.rst:197
msgid "``d``"
msgstr "``d``"

#: ../Doc/library/struct.rst:197
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: ../Doc/library/struct.rst:199
msgid "``s``"
msgstr "``s``"

#: ../Doc/library/struct.rst:199 ../Doc/library/struct.rst:201
msgid ":c:type:`char[]`"
msgstr ":c:type:`char[]`"

#: ../Doc/library/struct.rst:199 ../Doc/library/struct.rst:201
msgid "string"
msgstr "*string*"

#: ../Doc/library/struct.rst:201
msgid "``p``"
msgstr "``p``"

#: ../Doc/library/struct.rst:203
msgid "``P``"
msgstr "``P``"

#: ../Doc/library/struct.rst:203
msgid ":c:type:`void \\*`"
msgstr ":c:type:`void \\*`"

#: ../Doc/library/struct.rst:203
msgid "\\(5), \\(3)"
msgstr ""

#: ../Doc/library/struct.rst:209
msgid ""
"The ``'?'`` conversion code corresponds to the :c:type:`_Bool` type defined "
"by C99. If this type is not available, it is simulated using a :c:type:"
"`char`. In standard mode, it is always represented by one byte."
msgstr ""
"Le code de conversion ``'?'`` correspond au type :c:type:`_Bool` de C99. Si "
"ce type n'est pas disponible, il est simulé en utilisant un :c:type:`char`. "
"Dans le mode standard, il est toujours représenté par un octet."

#: ../Doc/library/struct.rst:216
msgid ""
"The ``'q'`` and ``'Q'`` conversion codes are available in native mode only "
"if the platform C compiler supports C :c:type:`long long`, or, on Windows, :"
"c:type:`__int64`.  They are always available in standard modes."
msgstr ""

#: ../Doc/library/struct.rst:223
msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`__index__` method then that method is "
"called to convert the argument to an integer before packing.  If no :meth:"
"`__index__` method exists, or the call to :meth:`__index__` raises :exc:"
"`TypeError`, then the :meth:`__int__` method is tried.  However, the use of :"
"meth:`__int__` is deprecated, and will raise :exc:`DeprecationWarning`."
msgstr ""

#: ../Doc/library/struct.rst:230
msgid "Use of the :meth:`__index__` method for non-integers is new in 2.7."
msgstr ""

#: ../Doc/library/struct.rst:233
msgid ""
"Prior to version 2.7, not all integer conversion codes would use the :meth:"
"`__int__` method to convert, and :exc:`DeprecationWarning` was raised only "
"for float arguments."
msgstr ""

#: ../Doc/library/struct.rst:239
msgid ""
"For the ``'f'`` and ``'d'`` conversion codes, the packed representation uses "
"the IEEE 754 binary32 (for ``'f'``) or binary64 (for ``'d'``) format, "
"regardless of the floating-point format used by the platform."
msgstr ""

#: ../Doc/library/struct.rst:244
msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"Le caractère de format ``'P'`` n'est disponible que pour le boutisme natif "
"(choisi par défaut ou à l'aide du caractère ``'@'`` de boutisme). Le "
"caractère de boutisme ``'='`` choisit d'utiliser un petit ou un gros en "
"fonction du système hôte. Le module *struct* ne l'interprète pas comme un "
"boutisme natif, donc le format ``'P'`` n'est pas disponible."

#: ../Doc/library/struct.rst:251
msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""
"Un caractère de format peut être précédé par un entier indiquant le nombre "
"de répétitions. Par exemple, la chaîne de format ``'4h'`` a exactement la "
"même signification que ``'hhhh'``."

#: ../Doc/library/struct.rst:254
msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""
"Les caractères d'espacement entre les indications de format sont ignorés ; "
"cependant, le nombre de répétitions et le format associé ne doivent pas être "
"séparés par des caractères d'espacement."

#: ../Doc/library/struct.rst:257
msgid ""
"For the ``'s'`` format character, the count is interpreted as the size of "
"the string, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string, while ``'10c'`` means 10 "
"characters. If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting string always has exactly the specified number "
"of bytes.  As a special case, ``'0s'`` means a single, empty string (while "
"``'0c'`` means 0 characters)."
msgstr ""

#: ../Doc/library/struct.rst:266
msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller. The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes count bytes, but that the string returned can never contain more "
"than 255 characters."
msgstr ""

#: ../Doc/library/struct.rst:276
msgid ""
"For the ``'P'`` format character, the return value is a Python integer or "
"long integer, depending on the size needed to hold a pointer when it has "
"been cast to an integer type.  A *NULL* pointer will always be returned as "
"the Python integer ``0``. When packing pointer-sized values, Python integer "
"or long integer objects may be used.  For example, the Alpha and Merced "
"processors use 64-bit pointer values, meaning a Python long integer will be "
"used to hold the pointer; other platforms use 32-bit pointers and will use a "
"Python integer."
msgstr ""

#: ../Doc/library/struct.rst:284
msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"Pour le caractère de format ``'?'``, la valeur renvoyée est :const:`True` "
"ou :const:`False`. Lors de l'agrégation, la valeur de vérité de l'objet "
"argument est utilisée. La valeur agrégée est 0 ou 1 dans la représentation "
"native ou standard et, lors de la dissociation, n'importe quelle valeur "
"différente de zéro est renvoyée ``True``."

#: ../Doc/library/struct.rst:294
msgid "Examples"
msgstr "Exemples"

#: ../Doc/library/struct.rst:297
msgid ""
"All examples assume a native byte order, size, and alignment with a big-"
"endian machine."
msgstr ""
"tous les exemples présentés supposent que l'on utilise le boutisme, la "
"taille et l'alignement natifs sur une machine gros-boutiste."

#: ../Doc/library/struct.rst:300
msgid "A basic example of packing/unpacking three integers::"
msgstr "Un exemple de base d'agrégation et dissociation de trois entiers ::"

#: ../Doc/library/struct.rst:310
msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""
"Les champs dissociés peuvent être nommés en leur assignant des variables ou "
"en encapsulant le résultat dans un *n*-uplet nommé ::"

#: ../Doc/library/struct.rst:321
msgid ""
"The ordering of format characters may have an impact on size since the "
"padding needed to satisfy alignment requirements is different::"
msgstr ""
"L'ordre des caractères de format peut avoir un impact sur la taille puisque "
"le bourrage nécessaire pour réaliser l'alignement est différent ::"

#: ../Doc/library/struct.rst:333
msgid ""
"The following format ``'llh0l'`` specifies two pad bytes at the end, "
"assuming longs are aligned on 4-byte boundaries::"
msgstr ""
"Le format suivant ``'llh0l'`` spécifie deux octets de bourrage à la fin, "
"considérant que les entiers longs sont alignés sur des espacements de 4 "
"octets ::"

#: ../Doc/library/struct.rst:339
msgid ""
"This only works when native size and alignment are in effect; standard size "
"and alignment does not enforce any alignment."
msgstr ""
"Ceci ne fonctionne que quand la taille et l'alignement natifs sont "
"utilisés ; la taille et l'alignement standards ne forcent aucun alignement."

#: ../Doc/library/struct.rst:346
msgid "Module :mod:`array`"
msgstr "Module :mod:`array`"

#: ../Doc/library/struct.rst:346
msgid "Packed binary storage of homogeneous data."
msgstr "Stockage agrégé binaire de données homogènes."

#: ../Doc/library/struct.rst:348
msgid "Module :mod:`xdrlib`"
msgstr "Module :mod:`xdrlib`"

#: ../Doc/library/struct.rst:349
msgid "Packing and unpacking of XDR data."
msgstr "Agrégation et dissociation de données XDR."

#: ../Doc/library/struct.rst:355
msgid "Classes"
msgstr "Classes"

#: ../Doc/library/struct.rst:357
msgid "The :mod:`struct` module also defines the following type:"
msgstr "Le module :mod:`struct` définit aussi le type suivant :"

#: ../Doc/library/struct.rst:362
msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a Struct object once and calling its "
"methods is more efficient than calling the :mod:`struct` functions with the "
"same format since the format string only needs to be compiled once."
msgstr ""
"Renvoie un nouvel objet Struct qui écrit et lit des données binaires "
"conformément à la chaîne de format *format*. Créer une fois pour toutes un "
"objet Struct puis appeler ses méthodes est plus efficace que d'appeler les "
"fonctions de :mod:`struct` avec le même format puisque la chaîne de format "
"n'est compilée qu'une seule fois."

#: ../Doc/library/struct.rst:369
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr ""
"Les objets ``Struct`` compilés gèrent les méthodes et attributs suivants :"

#: ../Doc/library/struct.rst:374
msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`self.size`.)"
msgstr ""

#: ../Doc/library/struct.rst:380
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""
"Identique à la fonction :func:`pack_into`, en utilisant le format compilé."

#: ../Doc/library/struct.rst:385
msgid ""
"Identical to the :func:`unpack` function, using the compiled format. "
"(``len(string)`` must equal :attr:`self.size`)."
msgstr ""

#: ../Doc/library/struct.rst:391
msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"(``len(buffer[offset:])`` must be at least :attr:`self.size`)."
msgstr ""

#: ../Doc/library/struct.rst:397
msgid "The format string used to construct this Struct object."
msgstr "La chaîne de format utilisée pour construire l'objet `Struct`."

#: ../Doc/library/struct.rst:401
msgid ""
"The calculated size of the struct (and hence of the string) corresponding "
"to :attr:`format`."
msgstr ""
